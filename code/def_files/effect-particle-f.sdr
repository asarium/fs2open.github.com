uniform sampler2D baseMap;
uniform sampler2D depthMap;
uniform float window_width;
uniform float window_height;
uniform float nearZ;
uniform float farZ;
uniform int linear_depth;
varying float radius_p;
varying vec4 position_p;
void main()
{
	vec4 fragmentColor = texture2D(baseMap, gl_TexCoord[0].xy)*gl_Color.a;
	vec2 offset = vec2(radius_p * abs(0.5 - gl_TexCoord[0].x) * 2.0, radius_p * abs(0.5 - gl_TexCoord[0].y) * 2.0);
	float offset_len = length(offset);
	if ( offset_len > radius_p ) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		return;
	}
	vec2 depthCoord = vec2(gl_FragCoord.x / window_width, gl_FragCoord.y / window_height );
	vec4 sceneDepth = texture2D(depthMap, depthCoord);
	float sceneDepthLinear;
	float fragDepthLinear;
	if ( linear_depth == 1 ) {
		sceneDepthLinear = -sceneDepth.z;
		fragDepthLinear = -position_p.z;
	} else {
		sceneDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - sceneDepth.x * (farZ-nearZ) );
		fragDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - gl_FragCoord.z * (farZ-nearZ) );
	}
	// assume UV of 0.5, 0.5 is the centroid of this sphere volume
	float depthOffset = sqrt(pow(radius_p, 2.0) - pow(offset_len, 2.0));
	float frontDepth = fragDepthLinear - depthOffset;
	float backDepth = fragDepthLinear + depthOffset;
	float ds = min(sceneDepthLinear, backDepth) - max(nearZ, frontDepth);
	fragmentColor = fragmentColor * ( ds / (depthOffset*2.0) );
	gl_FragColor = fragmentColor;
}