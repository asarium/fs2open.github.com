uniform sampler2D baseMap;
uniform sampler2D depthMap;
uniform float window_width;
uniform float window_height;
uniform float nearZ;
uniform float farZ;
varying float radius;
#ifdef FLAG_DISTORTION
uniform sampler2D distMap;
uniform sampler2D frameBuffer;
varying float offset_out;
#endif
void main()
{
 #ifndef FLAG_DISTORTION
	vec2 offset = vec2(radius * abs(0.5 - gl_TexCoord[0].x) * 2.0, radius * abs(0.5 - gl_TexCoord[0].y) * 2.0);
	float offset_len = length(offset);
	if (offset_len > radius) {
		gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
		return;
	}
	vec2 depthCoord = vec2(gl_FragCoord.x / window_width, gl_FragCoord.y / window_height );
	vec4 sceneDepth = texture2D(depthMap, depthCoord);
	float sceneDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - sceneDepth.x * (farZ-nearZ) );
	float fragDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - gl_FragCoord.z * (farZ-nearZ) );
	// assume UV of 0.5, 0.5 is the centroid of this sphere volume
	float depthOffset = sqrt(pow(radius, 2.0) - pow(offset_len, 2.0));
	float frontDepth = fragDepthLinear - depthOffset;
	float backDepth = fragDepthLinear + depthOffset;
	float ds = min(sceneDepthLinear, backDepth) - max(nearZ, frontDepth);
	vec4 fragmentColor = texture2D(baseMap, gl_TexCoord[0].xy)*gl_Color.a;
	fragmentColor = fragmentColor * ( ds / (depthOffset*2.0) );
	gl_FragColor = fragmentColor;
 #else
	vec2 depthCoord = vec2(gl_FragCoord.x / window_width, gl_FragCoord.y / window_height);
	vec4 fragmentColor = texture2D(baseMap, gl_TexCoord[0].xy)*gl_Color.a;
	vec2 distortion = texture2D(distMap, gl_TexCoord[0].xy+vec2(0.0, offset_out)).rg;
	float alpha = clamp(dot(fragmentColor.rgb,vec3(0.3333))*10.0,0.0,1.0);
	distortion = ((distortion - 0.5) * 0.01) * alpha;
	gl_FragColor = texture2D(frameBuffer,depthCoord+distortion);
	gl_FragColor.a = alpha;
 #endif
}